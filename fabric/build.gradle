plugins {
    id 'com.github.johnrengelman.shadow'
}

architectury {
    platformSetupLoomIde()
    fabric()
}

configurations {
    common
    shadowCommon
    compileClasspath.extendsFrom common
    runtimeClasspath.extendsFrom common
    developmentFabric.extendsFrom common

    // Files in this configuration will be bundled into your mod using the Shadow plugin.
    // Don't use the `shadow` configuration from the plugin itself as it's meant for excluding files.
//    shadowBundle {
//        canBeResolved = true
//        canBeConsumed = false
//    }
}

def figura_attach = (figura_is_snapshot == "True") ? "-SNAPSHOT" : ""

dependencies {
    modImplementation "net.fabricmc:fabric-loader:$fabric_loader_version"
    modLocalRuntime "net.fabricmc.fabric-api:fabric-api:$fabric_api_version+$minecraft_version"

    // Figura
    modImplementation "org.figuramc:figura-fabric:$figura+$minecraft_version$figura_attach"

    common(project(path: ':common', configuration: 'namedElements')) { transitive false }
    shadowCommon(project(path: ':common', configuration: 'transformProductionFabric')) { transitive false }

    include(implementation(annotationProcessor("io.github.llamalad7:mixinextras-fabric:$mixinextras")))
}

processResources {
    Map<String, Object> injectProperties = new HashMap<>()

    injectProperties.put 'version', project.version
    injectProperties.put 'minecraft_range_fabric', minecraft_range_fabric
    injectProperties.forEach { k, v -> inputs.property(k.toString(), v.toString()) }

    filesMatching('fabric.mod.json') {
        expand injectProperties
    }
}

shadowJar {
    configurations = [project.configurations.shadowCommon]
    archiveClassifier = 'dev-shadow'
}

remapJar {
    inputFile.set shadowJar.archiveFile
}
